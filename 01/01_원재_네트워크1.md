# 네트워크의 기초

## 네트워크란?

노드와 링크가 서로 연결되어 리소스를 공유하는 집합.

## 처리량과 지연시간

좋은 네트워크 = 높은 처리량, 짧은 지연시간, 적은 장애 빈도, 좋은 보안을 갖춘 네트워크

### 처리량(throughput)

성공적으로 전달된 데이터의 양. 단위로는 bps(bit per second)를 사용한다. 

처리량은 트래픽, 대역폭, 네트워크 중간에 발생하는 에러, 하드웨어 스펙에 영향을 받는다.

- 트래픽(traffic): 링크에 흐르는 데이터의 양, 또는 누적량
  - 특정 시점의 순간 트래픽 또는 특정 기간의 누적 트래픽

- 대역폭(bandwidth): 링크가 보낼 수 있는 이론상의 최대 처리량

### 지연시간

요청이 처리되는 시간이며, 메세지가 두 장치 사이를 왕복하는데 걸린 시간.

지연 시간은 매체 타입(무선, 유선), 패킷 크기, 라우터의 패킷처리 시간 등에 영향을 받는다.

## 네트워크 토폴로지와 병목 현상

### 네트워크 토폴로지

노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태.

#### 트리 토폴로지

트리와 같은 형태로 연결되어 있다. 노드의 추가와 삭제가 쉽고 특정 노드에 트래픽이 집중될 때 하위 노드에 영향을 끼칠 수 있다.

#### 버스 토폴로지

중앙 회선 하나에 여러개의 노드가 연결되어 있는 형태. 주로 LAN에서 사용한다. 설치 비용이 적고 신뢰성이 우수하며 회선에 노드를 추가하거나 삭제하기 쉽다. 하지만 스푸핑에 취약한 문제점이 있다.

> 스푸핑이란?
>
> 정상적으로 전송중인 패킷을 악의적인 다른 노드에 전달되도록 조작하는 것.

#### 스타 토폴로지

중앙의 노드에 다른 모든 노드들이 연결되어 있는 형태. 노드를 추가하거나 에러를 탐지하기 쉬우며 패킷 충돌 가능성이 적다. 노드에 에러가 발생하면 쉽게 추적할 수 있으며 다른 노드에 미치는 영향이 적다. 하지만 중앙 노드에 에러가 발생할 경우 전체 네트워크를 사용할 수 없으며 설치 비용이 높다는 단점이 있다.

#### 링형 토폴로지

고리와 같이 노드가 양 옆의 두 노드와 연결되어 있는 형태이다. 노드 수가 증가되어도 네트워크 손실이 없고 충돌 가능성이 적으며 노드의 고장을 쉽게 발견할 수 있다. 단점으로는 네트워크 구성을 변경하는 것이 어렵고 회선에 장애가 생기면 전체 네트워크에 영향을 미친다는 점이 있다.

#### 메시 토폴로지

모든 노드가 그물망처럼 각각 연결되어 있는 형태. 장애가 발생해도 다른 경로로 통신이 가능하기 때문에 네트워크를 계속 사용할 수 있고, 트래픽을 분산 처리할 수 있다는 장점이 있다. 하지만 노드 추가가 어렵고 비용이 높다는 단점이 있다.

### 병목현상

병목 현상은 전체 시스템의 성능이 하나의 구성 요소로 인해 제한되는 현상을 의미한다.

병목 현상의 주된 원인은 다음과 같다

- 네트워크 대역폭
- 네트워크 토폴로지
- 서버의 CPU, 메모리 등의 사용량
- 비효율적인 네트워크 구성

병목 현상을 해결하기 위해서는 네트워크 토폴로지가 어떻게 구성되어 있는지 파악하는 것이 중요하다. 어떤 토폴로지로 구성되어 있는지, 회선이 어떻게 연결되어 있는지 파악하면 병목 현상이 일어나는 곳을 쉽게 찾을 수 있다.

## 네트워크 분류

네트워크는 규모를 기반으로 분류할 수 있다.

- LAN
  - 근거리 통신망을 의미하며 건물이나 캠퍼스 등의 좁은 공간에서 운영된다.
- MAN
  - 대도시 지역 네트워크를 나타내며 도시와 같이 조금 더 넓은 지역에서 운영된다.
- WAN
  - 광역 네트워크를 의미하며 국가 또는 대륙 등의 넓은 지역에서 운영된다.

전송 속도는 LAN > MAN > WAN 이며, 혼잡도는 WAN > MAN > LAN 이다.

## 네트워크 성능 분석 명령어

네트워크의 문제인지를 파악하기 위해서 사용되는 명령어들

- ping
  - 특정 노드로 패킷을 보내는 명령어. 패킷 수신 상태와 도달하기까지의 시간 등을 알 수 있어, 해당 노드까지 잘 연결되어 있는지 확인할 수 있다. ICMP 프로토콜 통해 동작한다.
- netstat
  - 접속되어 있는 서비스들의 네트워크 상태를 표시하는 명령어이다. 네트워크 접속, 라우팅 테이블, 네트워크 프로토콜 등의 리스트를 보여준다. 주로 서비스의 포트가 열려있는지 확인할 때 사용한다..
- nslookup
  - 특정 도메인에 매핑된 ip를 확인하기 위한 명령어.
- tracert
  - 목적지 노드까지 가는 경로는 확인하는 명령어.

## 네트워크 프로토콜 표준화

네트워크 포로토콜이란 다른 장치들끼리 데이터를 주고 받기 위해 만든 공통된 인터페이스이다. IEEE 또는 IETF라는 표준화 단체가 이를 지정한다.

예를 들어, IEEE 802.3은 유선 LAN 프로토콜이다. 웹을 접속할 때 쓰이는 HTTP도 있다. 이렇게 서로 약속된 프로토콜로 통신하게 되면 다른 장치라도 서로 데이터를 주고 받을 수 있다.

# TCP/IP 4계층 모델

## 계층 구조

TCP/IP 4계층

- 어플리케이션 계층
- 전송 계층
- 인터넷 계층
- 링크 계층

OSI 7계층

- 어플리케이션 계층
- 프레전테이션 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

TCP/IP 4계층은 OSI의 상위 3계층을 어플리케이션 계층으로, 하위 2계층을 링크 계층으로 통합해서 처리한다. 또한 네트워크 계층을 인터넷 계층으로 표현하는 점이 다르다.

각각의 계층들은 서로 독립적이기 때문에, 다른 계층이 변경되어도 서로 영향을 받지 않도록 설계되었다.

### 어플리케이션 계층

어플리케이션 계층은 응용 프로그램이 사용되는 계층이며 웹, 이메일 등의 실질적인 서비스를 제공하는 계층이다.

- HTTP
  - 웹 통신에 사용되는 프로토콜
- FTP
  - 파일 전송에 사용되는 프로토콜
- SSH
  - 네트워크를 통해 원격 컴퓨터에 안전하게 접속하기 위한 프로토콜
- SMTP
  - 이메일을 전송하기 위한 프로토콜
- DNS
  - ip 주소와 도메인 이름을 매핑해주는 프로토콜

### 전송 계층

전송 계층은 송신자와 수신자를 연결하는 통신 서비스를 제공한다. 대표적으로 TCP와 UDP가 존재한다

#### TCP

TCP는 신뢰성있는 연결을 제공하는 프로토콜이다. 

3-way-handshake는 TCP가 신뢰성을 제공하는 방법이다. 과정은 다음과 같다

- 클라이언트는 접속하려는 서버에 임의의 isn 값을 seq에 넣고 syn 플래그를 1로 설정해 패킷을 보낸다(syn)
- syn 패킷을 받은 서버는 임의의 isn 값을 seq로 하고, 클라이언트가 보낸 seq 값에 1을 더한 값을 ack로 보낸다(syn + ack)
- 클라이언트는 서버의 seq값에 1을 더한 값을 ack로 보낸다. (ack)

4-way-handshake는 연결을 종료할 때 필요한 과정이다.

- 클라이언트가 fin 패킷을 전송한다. 이후 클라이언트는 fin_wait_1 상태로 변해 응답을 대기한다
- 서버가 패킷을 받으면 응답으로 ack 패킷을 전송한다. 이때 서버는 close_wait 상태로 대기한다
- 서버는 fin 패킷을 클라이언트에게 전송하고 lask_ack 상태로 변한다
- 클라이언트는 서버의 ack를 받은 후 fin_wait_2 상태로 대기하다가 fin 패킷을 받으면 서버에게 ack를 보내고 time_wait 상태로 일정 시간 대기 후에 연결을 종료한다.
- 서버가 마지막으로 ack를 받으면 연결이 종료된다.

클라이언트가 time_wait 상태로 대기하는 이유는 지연 패킷이 발생했을 경우를 대비하기 위해서이다. fin 패킷 이전에 생성된 패킷이 fin 패킷 이후에 도착한다면 데이터의 유실이 발생할 수 있고 데이터 무결성이 깨질 가능성이 존재한다. 또한 서버 측이 last_ack인 상태에서 클라이언트가 연결을 닫게 된다면 새 연결을 시도할 때 last_ack 상태이기 때문에 연결에 오류가 발생할 수도 있다. 따라서 time_wait 상태로 일정 시간 대기한 후에 연결을 종료하도록 해야 문제가 발생하지 않는다.

### 인터넷 계층

인터넷 계층은 패킷을 ip 주소로 지정된 목적지로 전송하기 위해서 사용하는 계층이다. IP, ARP, ICMP 등의 프로토콜이 존재한다. 상대방이 잘 받았는지에 대한 여부는 상위 계층인 전송 계층에서 담당하며 인터넷 계층에서는 이것을 보장하지 않는다

### 링크 계층

링크 계층은 실질적으로 데이터를 전달하며 장치 간에 신호를 주고받는 규칙을 정하는 계층이다. OSI 7계층에서의 물리 계층은 0과 1의 데이터를 직접 보내는 계층이며, 데이터 링크 계층은 이더넷 프레임을 통해 에러 확인, 흐름 제어, 접근 제어 등을 담당하는 계층이다.

#### 유선

유선 LAN은 이더넷 프로토콜을 따르며 전이중화 통신을 사용한다.

전이중화 통신은 양쪽 장치가 동시에 송수신 할 수 있는 통신 방식이다. 송신용 링크와 수신용 링크를 나누어 동시에 데이터를 주고 받을 수 있다.

과거에는 CSMA/CD를 사용한 반이중화 방식으로 통신했다. CSMA/CD는 데이터를 보낼 때 충돌이 발생하는것이 감지되면 일정 시간 대기 후에 재전송하는 방식이다.

케이블로는 트위스트 페어 케이블과 광섬유 케이블을 사용한다.

- 트위스트 페어 케이블
  - 8개의 구리선을 꼬아 묶은 케이블
  - UTP: 구리선을 실드 처리하지 않은 케이블. 흔히 부르는 LAN 케이블이 이 케이블이다.
  - STP: 구리선을 실드 처리한 케이블
- 광섬유 케이블
  - 광섬유를 이용해서 만든 케이블
  - 빛을 이용하기 때문에 구리선보다 더 먼거리를 훨씬 빠르게 전송할 수 있다.

#### 무선

무선 LAN은 수신과 송신에 같은 채널을 사용하기 때문에 반이중화 방식을 사용해서 통신한다.

반이중화 통신은 양쪽 장치가 동시에 송수신할 수 없고 송신 또는 수신만 가능한 통신 방법이다. 무선인 경우 CDMA/CA를 사용한다. CDMA/CA는 CDMA/CD와 다르게 충돌을 감지하는 것이 아닌 충돌을 피하는 방식을 사용한다. 과정은 다음과 같다.

- 사용중인 채널이 있으면 유휴 상태인 다른 채널을 찾는다
- 프레임간 공간 시간인 IFS 시간만큼 기다린다. IFS는 프레임의 우선 순위를 정의할 때도 사용된다.
- 프레임을 보내기 전에 0 ~ 2^k - 1의 랜덤 상수를 기반으로 결정된 시간만큼 대기한 후 프레임을 전송한다
  - 잘 송신이 되었고 ack를 받았으면 전송 종료
  - 송신이 되지 않았다면 k + 1을 반복하며 송신을 계속 시도한다. k가 최대값보다 커진다면 abort한다.

무선 랜은 공기에 주파수를 쏘아서 무선 통신망을 구축한다. 주파수 대역은 2.4GHz와 5Ghz가 있다. 2.4GHz는 장애물에 영향을 상대적으로 덜 받지만 다른 전파와 간섭이 일어나는 경우가 많다. 5GHz는 사용할 수 있는 채널이 많고 동시에 사용할 수 있기 때문에 상대적으로 깨끗한 전파 환경을 구축할 수 있다.

와이파이는 무선 랜 신호에 연결할 수 있게 하는 기술로 접속하려면 무선 AP장치가 필요하다. 이를 흔히 공유기라고 하며 유선 신호를 무선 신호로 바꿔서 무선으로 인터넷에 접속할 수 있게 해준다.

#### 이더넷 프레임

데이터 링크 계층은 이더넷 프레임을 통해 전달받은 데이터의 에러를 검출하고 캡슐화 하며 다음과 같은 구조를 가진다.

- Preamble
  - 이더넷 프레임이 시작됨을 알림
- SFD
  - 다음 바이트부터 MAC 주소 필드가 시작됨을 알림
- DMAC, SMAC
  - 송신, 수신 MAC 주소
- EtherType
  - 상위 계층인 IP 프로토콜을 정의함. (IPv4, IPv6)
- Payload
  - 전달받은 데이터
- CRC
  - 에러 확인 비트

### 계층 간 데이터 송수신 과정

사용자가 다른 컴퓨터로 데이터를 요청한다면 어떤 일이 일어날까?

애플리케이션 계층 - 전송 계층 - 인터넷 계층 - 링크 계층을 순서대로 내려가면서 데이터가 캡슐화된다. 캡슐화는 원본 데이터에 각 계층의 헤더를 계속 붙여나가는 과정이다. 전송 계층에서 TCP(UDP) 헤더가 붙어 세그먼트(데이터그램)가 되고, 인터넷 계층에서 IP 헤더가 붙어 패킷, 링크 계층에서 이더넷 헤더가 붙어서 프레임이 된다. 수신 컴퓨터에서는 이런 캡슐화 과정을 역으로 진행하는 비캡슐화 과정이 진행된다. 

위에서 말한 세그먼트, 패킷, 프레임 등을 PDU라고 한다. 어플리케이션 계층은 메세지라고 하고, 문자열로 이루어져 있다. 

# Spring IOC, DI

## IOC

프레임워크는 원하는 기능 구현에 집중하여 개발할 수 있도록 일정한 형태와 기능을 갖추고 있는, 뼈대와 같은 역할을 한다. 프로그램 개발 시 필수적인 코드나 DB 연동과 같은 기능을 위해서 어느정도 뼈대를 제공하고, 사용자는 프레임워크가 제공해주는 구조대로 코드를 작성한다.

라이브러리는 특정 기능을 하는 코드를 모아놓은 것으로 프로그램을 개발할 때 사용 가능한 도구로서의 역할을 한다. 

라이브러리는 프레임워크와 유사한 기능을 하지만 핵심적인 차이는 **흐름을 누가 제어하느냐**이다. 라이브러리는 사용하는 사람이 직접 전체적인 흐름을 제어해야 한다. 개발 시에 필요한 기능이 있으면 가져다가 사용하는 방식이다. 반면 프레임워크는 전체적인 흐름을 프레임워크가 제어한다. 애플리케이션 코드는 프레임워크에 의해 실행된다. 애플리케이션 코드는 프레임워크의 구조 위에서 수동적으로 동작하며 사용자는 그 틀 안에서 필요한 코드를 작성한다.

이렇게 프로그램의 흐름을 사용자가 직접 제어하는 것이 아닌 외부에서 관리하는 것을 **IOC(Inversion of Controll)**라고 한다. 스프링의 IOC 컨테이너는 객체의 생성, 소멸 등의 생명 주기를 대신 관리해준다. 그리고 적절한 객체를 주입해준다. 객체의 제어권이 개발자에서 스프링 프레임워크로 넘어간 것이다. 

IOC의 장점은 다음과 같다

- 결합도 감소
  - 특정 구현에 종속되지 않고 어떤 객체가 필요한지만 알고 있으면 된다. 스프링이 외부에서 적절한 객체을 주입해 준다.
- 테스트 용이성
  - 의존성을 외부에서 주입할 수 있기 때문에 mock 객체를 쉽게 넣을 수 있다.
- 객체 재사용성 증가
  - 특정 구현에 종속되지 않기 때문에 잘 만들어진 모듈은 재사용이 가능하다.
- 유연성과 확장성
  - 결합도가 낮아졌기 때문에 기존 기능에 영향을 주지 않고 새 기능을 쉽게 추가하거나 변경할 수 있다.

## DI

**DI(Dependency Injection)**는 IOC를 구현하는 방법 중 하나이다. 객체가 의존하고 있는 다른 객체를 내부에서 직접 만들어서 사용하지 않고 스프링 컨테이너가 외부에서 주입해주는 방식이다. 스프링에서는 **@Autowired** 어노테이션으로 의존성을 주입받을 수 있다.

의존관계 자동 주입 방법에는 크게 3가지가 있다. 

### 1. 생성자 주입

```java
@Autowired
public OrderServiceImpl(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

생성자를 통해 주입받는 방식이다.  

생성자 호출 시점(객체가 생생되는 시점)에 단 한번만 호출되고, final 키워드를 붙일 수 있어서 불변이는 특징이 있다.  

불변이라는 특징 때문에 주로 사용되는 방식이다.  

### 2. 필드 주입

```java
@Autowired
private MemberRepository memberRepository;
```

필드에 바로 주입받는 방식이다.  

코드가 간결해지는 장점이 있지만 외부에서 변경이 불가능해서 테스트가 힘들다는 단점이 있어 사용되지 않는다.  

테스트 코드에서만 사용한다.  

### 3. setter 주입

```java
@Autowired
public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

setter를 통해 주입받는 방식이다.  

대부분의 경우 의존관계는 한번 설정되면 바뀌지 않아야 한다.  

하지만 setter를 사용하는 방식은 메서드가 public으로 열려있어 다른 곳에서 수정할 수 있기 때문에 권장되지 않는 방식이다.  

선택적인 의존 관계 주입이나, 변경이 필요할 때 제한적으로 사용한다.  

